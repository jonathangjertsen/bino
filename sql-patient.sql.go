// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-patient.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPatient = `-- name: AddPatient :one
INSERT INTO patient (species_id, name, curr_home_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type AddPatientParams struct {
	SpeciesID  int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
}

func (q *Queries) AddPatient(ctx context.Context, arg AddPatientParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatient,
		arg.SpeciesID,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getActivePatients = `-- name: GetActivePatients :many
SELECT p.id, p.name, p.curr_home_id, p.status, p.journal_url, COALESCE(sl.name, '???') AS species FROM patient AS p
LEFT JOIN species_language AS sl
    ON sl.species_id = p.species_id
WHERE curr_home_id IS NOT NULL
  AND language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetActivePatientsRow struct {
	ID         int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
	JournalUrl pgtype.Text
	Species    string
}

func (q *Queries) GetActivePatients(ctx context.Context, languageID int32) ([]GetActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivePatientsRow
	for rows.Next() {
		var i GetActivePatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentPatientsForHome = `-- name: GetCurrentPatientsForHome :many
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.curr_home_id = $1
  AND sl.language_id = $2
ORDER BY p.sort_order, p.id
`

type GetCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetCurrentPatientsForHomeRow struct {
	ID          int32
	SpeciesID   int32
	CurrHomeID  pgtype.Int4
	Name        string
	Status      int32
	JournalUrl  pgtype.Text
	SortOrder   int32
	SpeciesName string
}

func (q *Queries) GetCurrentPatientsForHome(ctx context.Context, arg GetCurrentPatientsForHomeParams) ([]GetCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetCurrentPatientsForHomeRow
		if err := rows.Scan(
			&i.ID,
			&i.SpeciesID,
			&i.CurrHomeID,
			&i.Name,
			&i.Status,
			&i.JournalUrl,
			&i.SortOrder,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormerPatients = `-- name: GetFormerPatients :many
SELECT p.id, p.name, p.curr_home_id, p.status, COALESCE(sl.name, '???') AS species FROM patient AS p
LEFT JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE curr_home_id IS NULL
  AND sl.language_id = $1
ORDER BY p.id DESC
`

type GetFormerPatientsRow struct {
	ID         int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
	Species    string
}

func (q *Queries) GetFormerPatients(ctx context.Context, languageID int32) ([]GetFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFormerPatientsRow
	for rows.Next() {
		var i GetFormerPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatient = `-- name: GetPatient :one
SELECT id, species_id, curr_home_id, name, status, journal_url, sort_order FROM patient
WHERE id = $1
`

func (q *Queries) GetPatient(ctx context.Context, id int32) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatient, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
	)
	return i, err
}

const getPatientWithSpecies = `-- name: GetPatientWithSpecies :one
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.id = $1
  AND sl.language_id = $2
`

type GetPatientWithSpeciesParams struct {
	ID         int32
	LanguageID int32
}

type GetPatientWithSpeciesRow struct {
	ID          int32
	SpeciesID   int32
	CurrHomeID  pgtype.Int4
	Name        string
	Status      int32
	JournalUrl  pgtype.Text
	SortOrder   int32
	SpeciesName string
}

func (q *Queries) GetPatientWithSpecies(ctx context.Context, arg GetPatientWithSpeciesParams) (GetPatientWithSpeciesRow, error) {
	row := q.db.QueryRow(ctx, getPatientWithSpecies, arg.ID, arg.LanguageID)
	var i GetPatientWithSpeciesRow
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.SpeciesName,
	)
	return i, err
}

const movePatient = `-- name: MovePatient :exec
UPDATE patient
SET curr_home_id = $2
WHERE id = $1
`

type MovePatientParams struct {
	ID         int32
	CurrHomeID pgtype.Int4
}

func (q *Queries) MovePatient(ctx context.Context, arg MovePatientParams) error {
	_, err := q.db.Exec(ctx, movePatient, arg.ID, arg.CurrHomeID)
	return err
}

const setPatientJournal = `-- name: SetPatientJournal :exec
UPDATE patient
SET journal_url = $2
WHERE id = $1
`

type SetPatientJournalParams struct {
	ID         int32
	JournalUrl pgtype.Text
}

func (q *Queries) SetPatientJournal(ctx context.Context, arg SetPatientJournalParams) error {
	_, err := q.db.Exec(ctx, setPatientJournal, arg.ID, arg.JournalUrl)
	return err
}

const setPatientName = `-- name: SetPatientName :exec
UPDATE patient
SET name = $2
WHERE id = $1
`

type SetPatientNameParams struct {
	ID   int32
	Name string
}

func (q *Queries) SetPatientName(ctx context.Context, arg SetPatientNameParams) error {
	_, err := q.db.Exec(ctx, setPatientName, arg.ID, arg.Name)
	return err
}

const setPatientStatus = `-- name: SetPatientStatus :exec
UPDATE patient
SET status = $2
WHERE id = $1
`

type SetPatientStatusParams struct {
	ID     int32
	Status int32
}

func (q *Queries) SetPatientStatus(ctx context.Context, arg SetPatientStatusParams) error {
	_, err := q.db.Exec(ctx, setPatientStatus, arg.ID, arg.Status)
	return err
}

const updatePatientSortOrder = `-- name: UpdatePatientSortOrder :exec
UPDATE patient as p
SET sort_order = v.sort_order
FROM (
  SELECT UNNEST($1::int[]) AS id,
         UNNEST($2::int[]) AS sort_order
) AS v
WHERE p.id = v.id
`

type UpdatePatientSortOrderParams struct {
	Ids    []int32
	Orders []int32
}

func (q *Queries) UpdatePatientSortOrder(ctx context.Context, arg UpdatePatientSortOrderParams) error {
	_, err := q.db.Exec(ctx, updatePatientSortOrder, arg.Ids, arg.Orders)
	return err
}
