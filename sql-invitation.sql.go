// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-invitation.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :execresult
DELETE FROM invitation
WHERE expires < NOW()
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteExpiredInvitations)
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitation
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const deleteInvitationByEmail = `-- name: DeleteInvitationByEmail :exec
DELETE FROM invitation
WHERE email = $1
`

func (q *Queries) DeleteInvitationByEmail(ctx context.Context, email pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteInvitationByEmail, email)
	return err
}

const getInvitation = `-- name: GetInvitation :one
SELECT id
FROM invitation
WHERE email = $1
  AND expires > NOW()
`

func (q *Queries) GetInvitation(ctx context.Context, email pgtype.Text) (string, error) {
	row := q.db.QueryRow(ctx, getInvitation, email)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getInvitations = `-- name: GetInvitations :many
SELECT invitation.id, email, expires, created, access_level, home, home.id, name, capacity, note, home.name AS home_name
FROM invitation
LEFT JOIN home
  ON home.id = invitation.home
WHERE expires > NOW()
ORDER BY created DESC
`

type GetInvitationsRow struct {
	ID          string
	Email       pgtype.Text
	Expires     pgtype.Timestamptz
	Created     pgtype.Timestamptz
	AccessLevel int32
	Home        pgtype.Int4
	ID_2        pgtype.Int4
	Name        pgtype.Text
	Capacity    pgtype.Int4
	Note        pgtype.Text
	HomeName    pgtype.Text
}

func (q *Queries) GetInvitations(ctx context.Context) ([]GetInvitationsRow, error) {
	rows, err := q.db.Query(ctx, getInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInvitationsRow
	for rows.Next() {
		var i GetInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Expires,
			&i.Created,
			&i.AccessLevel,
			&i.Home,
			&i.ID_2,
			&i.Name,
			&i.Capacity,
			&i.Note,
			&i.HomeName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertInvitation = `-- name: InsertInvitation :exec
INSERT INTO invitation (
  id,
  email,
  expires,
  created
) VALUES (
  $1,
  $2,
  $3,
  $4
)
`

type InsertInvitationParams struct {
	ID      string
	Email   pgtype.Text
	Expires pgtype.Timestamptz
	Created pgtype.Timestamptz
}

func (q *Queries) InsertInvitation(ctx context.Context, arg InsertInvitationParams) error {
	_, err := q.db.Exec(ctx, insertInvitation,
		arg.ID,
		arg.Email,
		arg.Expires,
		arg.Created,
	)
	return err
}
