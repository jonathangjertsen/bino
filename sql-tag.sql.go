// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-tag.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPatientTags = `-- name: AddPatientTags :exec
INSERT INTO patient_tag (patient_id, tag_id)
VALUES ($1, unnest($2::INT[]))
ON CONFLICT (patient_id, tag_id) DO NOTHING
`

type AddPatientTagsParams struct {
	PatientID int32
	Tags      []int32
}

func (q *Queries) AddPatientTags(ctx context.Context, arg AddPatientTagsParams) error {
	_, err := q.db.Exec(ctx, addPatientTags, arg.PatientID, arg.Tags)
	return err
}

const addTag = `-- name: AddTag :one
INSERT INTO tag (default_show)
    VALUES ($1)
RETURNING id
`

func (q *Queries) AddTag(ctx context.Context, defaultShow bool) (int32, error) {
	row := q.db.QueryRow(ctx, addTag, defaultShow)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deletePatientTag = `-- name: DeletePatientTag :exec
DELETE FROM patient_tag
WHERE patient_id = $1
  AND tag_id = $2
`

type DeletePatientTagParams struct {
	PatientID int32
	TagID     int32
}

func (q *Queries) DeletePatientTag(ctx context.Context, arg DeletePatientTagParams) error {
	_, err := q.db.Exec(ctx, deletePatientTag, arg.PatientID, arg.TagID)
	return err
}

const getTagName = `-- name: GetTagName :one
SELECT name FROM tag_language
WHERE language_id = $1
  AND tag_id = $2
`

type GetTagNameParams struct {
	LanguageID int32
	TagID      int32
}

func (q *Queries) GetTagName(ctx context.Context, arg GetTagNameParams) (string, error) {
	row := q.db.QueryRow(ctx, getTagName, arg.LanguageID, arg.TagID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getTags = `-- name: GetTags :many
SELECT id, default_show FROM tag
ORDER BY id
`

func (q *Queries) GetTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.DefaultShow); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForActivePatients = `-- name: GetTagsForActivePatients :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
LEFT JOIN patient AS p
    ON p.id = pt.patient_id
WHERE p.curr_home_id IS NOT NULL
AND tl.language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetTagsForActivePatientsRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForActivePatients(ctx context.Context, languageID int32) ([]GetTagsForActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getTagsForActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForActivePatientsRow
	for rows.Next() {
		var i GetTagsForActivePatientsRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForCurrentPatientsForHome = `-- name: GetTagsForCurrentPatientsForHome :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name
FROM patient_tag AS pt
LEFT JOIN tag_language as tl
  ON tl.tag_id = pt.tag_id
LEFT JOIN patient as p
  ON p.id = pt.patient_id
WHERE p.curr_home_id = $1
  AND tl.language_id = $2
`

type GetTagsForCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetTagsForCurrentPatientsForHomeRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForCurrentPatientsForHome(ctx context.Context, arg GetTagsForCurrentPatientsForHomeParams) ([]GetTagsForCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getTagsForCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetTagsForCurrentPatientsForHomeRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForFormerPatients = `-- name: GetTagsForFormerPatients :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
LEFT JOIN patient AS p
    ON p.id = pt.patient_id
WHERE p.curr_home_id IS NULL
AND tl.language_id = $1
`

type GetTagsForFormerPatientsRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForFormerPatients(ctx context.Context, languageID int32) ([]GetTagsForFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getTagsForFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForFormerPatientsRow
	for rows.Next() {
		var i GetTagsForFormerPatientsRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForPatient = `-- name: GetTagsForPatient :many
SELECT pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
WHERE pt.patient_id = $1
  AND tl.language_id = $2
`

type GetTagsForPatientParams struct {
	PatientID  int32
	LanguageID int32
}

type GetTagsForPatientRow struct {
	TagID int32
	Name  string
}

func (q *Queries) GetTagsForPatient(ctx context.Context, arg GetTagsForPatientParams) ([]GetTagsForPatientRow, error) {
	rows, err := q.db.Query(ctx, getTagsForPatient, arg.PatientID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForPatientRow
	for rows.Next() {
		var i GetTagsForPatientRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsLanguage = `-- name: GetTagsLanguage :many
SELECT tag_id, language_id, name FROM tag_language
ORDER BY (tag_id, language_id)
`

func (q *Queries) GetTagsLanguage(ctx context.Context) ([]TagLanguage, error) {
	rows, err := q.db.Query(ctx, getTagsLanguage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagLanguage
	for rows.Next() {
		var i TagLanguage
		if err := rows.Scan(&i.TagID, &i.LanguageID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsWithLanguage = `-- name: GetTagsWithLanguage :many
SELECT tag_id, name FROM tag_language
WHERE language_id = $1
ORDER BY (tag_id)
`

type GetTagsWithLanguageRow struct {
	TagID int32
	Name  string
}

func (q *Queries) GetTagsWithLanguage(ctx context.Context, languageID int32) ([]GetTagsWithLanguageRow, error) {
	rows, err := q.db.Query(ctx, getTagsWithLanguage, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsWithLanguageRow
	for rows.Next() {
		var i GetTagsWithLanguageRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsWithLanguageCheckin = `-- name: GetTagsWithLanguageCheckin :many
SELECT tag_id, name, default_show FROM tag_language
INNER JOIN tag AS t
    ON t.id = tag_language.tag_id
WHERE language_id = $1
ORDER BY (default_show, tag_id) DESC
`

type GetTagsWithLanguageCheckinRow struct {
	TagID       int32
	Name        string
	DefaultShow bool
}

func (q *Queries) GetTagsWithLanguageCheckin(ctx context.Context, languageID int32) ([]GetTagsWithLanguageCheckinRow, error) {
	rows, err := q.db.Query(ctx, getTagsWithLanguageCheckin, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsWithLanguageCheckinRow
	for rows.Next() {
		var i GetTagsWithLanguageCheckinRow
		if err := rows.Scan(&i.TagID, &i.Name, &i.DefaultShow); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTagDefaultShown = `-- name: UpdateTagDefaultShown :exec
UPDATE tag SET default_show = $1
WHERE id = $2
`

type UpdateTagDefaultShownParams struct {
	DefaultShow bool
	ID          int32
}

func (q *Queries) UpdateTagDefaultShown(ctx context.Context, arg UpdateTagDefaultShownParams) error {
	_, err := q.db.Exec(ctx, updateTagDefaultShown, arg.DefaultShow, arg.ID)
	return err
}

const upsertTagLanguage = `-- name: UpsertTagLanguage :exec
INSERT INTO tag_language (tag_id, language_id, name)
VALUES ($1, $2, $3)
ON CONFLICT (tag_id, language_id) DO UPDATE
    SET name = EXCLUDED.name
`

type UpsertTagLanguageParams struct {
	TagID      int32
	LanguageID int32
	Name       string
}

func (q *Queries) UpsertTagLanguage(ctx context.Context, arg UpsertTagLanguageParams) error {
	_, err := q.db.Exec(ctx, upsertTagLanguage, arg.TagID, arg.LanguageID, arg.Name)
	return err
}
