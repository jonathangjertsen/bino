// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPatient = `-- name: AddPatient :one
INSERT INTO patient (species_id, name, curr_home_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type AddPatientParams struct {
	SpeciesID  int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
}

func (q *Queries) AddPatient(ctx context.Context, arg AddPatientParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatient,
		arg.SpeciesID,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPatientEvent = `-- name: AddPatientEvent :one
INSERT INTO patient_event (patient_id, home_id, event_id, associated_id, note, appuser_id, time)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type AddPatientEventParams struct {
	PatientID    int32
	HomeID       int32
	EventID      int32
	AssociatedID pgtype.Int4
	Note         string
	AppuserID    int32
	Time         pgtype.Timestamptz
}

func (q *Queries) AddPatientEvent(ctx context.Context, arg AddPatientEventParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatientEvent,
		arg.PatientID,
		arg.HomeID,
		arg.EventID,
		arg.AssociatedID,
		arg.Note,
		arg.AppuserID,
		arg.Time,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPatientTags = `-- name: AddPatientTags :exec
INSERT INTO patient_tag (patient_id, tag_id)
VALUES ($1, unnest($2::INT[]))
ON CONFLICT (patient_id, tag_id) DO NOTHING
`

type AddPatientTagsParams struct {
	PatientID int32
	Tags      []int32
}

func (q *Queries) AddPatientTags(ctx context.Context, arg AddPatientTagsParams) error {
	_, err := q.db.Exec(ctx, addPatientTags, arg.PatientID, arg.Tags)
	return err
}

const addPreferredSpecies = `-- name: AddPreferredSpecies :exec
INSERT INTO home_preferred_species (
  home_id,
  species_id
) VALUES (
  $1,
  $2
)
`

type AddPreferredSpeciesParams struct {
	HomeID    int32
	SpeciesID int32
}

func (q *Queries) AddPreferredSpecies(ctx context.Context, arg AddPreferredSpeciesParams) error {
	_, err := q.db.Exec(ctx, addPreferredSpecies, arg.HomeID, arg.SpeciesID)
	return err
}

const addSpecies = `-- name: AddSpecies :one
INSERT INTO species (scientific_name)
VALUES ($1)
RETURNING id
`

func (q *Queries) AddSpecies(ctx context.Context, scientificName string) (int32, error) {
	row := q.db.QueryRow(ctx, addSpecies, scientificName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addTag = `-- name: AddTag :one
INSERT INTO tag (default_show)
    VALUES ($1)
RETURNING id
`

func (q *Queries) AddTag(ctx context.Context, defaultShow bool) (int32, error) {
	row := q.db.QueryRow(ctx, addTag, defaultShow)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addUserToHome = `-- name: AddUserToHome :exec
INSERT INTO home_appuser (home_id, appuser_id)
VALUES ($1, $2)
`

type AddUserToHomeParams struct {
	HomeID    int32
	AppuserID int32
}

func (q *Queries) AddUserToHome(ctx context.Context, arg AddUserToHomeParams) error {
	_, err := q.db.Exec(ctx, addUserToHome, arg.HomeID, arg.AppuserID)
	return err
}

const clearAllUserGDriveAccess = `-- name: ClearAllUserGDriveAccess :exec
UPDATE appuser
SET has_gdrive_access = FALSE
WHERE 1
`

func (q *Queries) ClearAllUserGDriveAccess(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAllUserGDriveAccess)
	return err
}

const deleteAppuser = `-- name: DeleteAppuser :exec
DELETE
FROM appuser
WHERE id = $1
`

func (q *Queries) DeleteAppuser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAppuser, id)
	return err
}

const deleteAppuserLanguage = `-- name: DeleteAppuserLanguage :exec
DELETE
FROM appuser_language
WHERE appuser_id = $1
`

func (q *Queries) DeleteAppuserLanguage(ctx context.Context, appuserID int32) error {
	_, err := q.db.Exec(ctx, deleteAppuserLanguage, appuserID)
	return err
}

const deleteEventsCreatedByUser = `-- name: DeleteEventsCreatedByUser :exec
DELETE
FROM patient_event
WHERE appuser_id = $1
`

func (q *Queries) DeleteEventsCreatedByUser(ctx context.Context, appuserID int32) error {
	_, err := q.db.Exec(ctx, deleteEventsCreatedByUser, appuserID)
	return err
}

const deleteExpiredInvitations = `-- name: DeleteExpiredInvitations :execresult
DELETE FROM invitation
WHERE expires < NOW()
`

func (q *Queries) DeleteExpiredInvitations(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteExpiredInvitations)
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM invitation
WHERE id = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteInvitation, id)
	return err
}

const deleteInvitationByEmail = `-- name: DeleteInvitationByEmail :exec
DELETE FROM invitation
WHERE email = $1
`

func (q *Queries) DeleteInvitationByEmail(ctx context.Context, email pgtype.Text) error {
	_, err := q.db.Exec(ctx, deleteInvitationByEmail, email)
	return err
}

const deletePatientTag = `-- name: DeletePatientTag :exec
DELETE FROM patient_tag
WHERE patient_id = $1
  AND tag_id = $2
`

type DeletePatientTagParams struct {
	PatientID int32
	TagID     int32
}

func (q *Queries) DeletePatientTag(ctx context.Context, arg DeletePatientTagParams) error {
	_, err := q.db.Exec(ctx, deletePatientTag, arg.PatientID, arg.TagID)
	return err
}

const deletePreferredSpecies = `-- name: DeletePreferredSpecies :exec
DELETE FROM home_preferred_species
WHERE home_id    = $1
  AND species_id = $2
`

type DeletePreferredSpeciesParams struct {
	HomeID    int32
	SpeciesID int32
}

func (q *Queries) DeletePreferredSpecies(ctx context.Context, arg DeletePreferredSpeciesParams) error {
	_, err := q.db.Exec(ctx, deletePreferredSpecies, arg.HomeID, arg.SpeciesID)
	return err
}

const deleteSessionsForUser = `-- name: DeleteSessionsForUser :exec
DELETE
FROM session
WHERE appuser_id = $1
`

func (q *Queries) DeleteSessionsForUser(ctx context.Context, appuserID int32) error {
	_, err := q.db.Exec(ctx, deleteSessionsForUser, appuserID)
	return err
}

const deleteStaleSessions = `-- name: DeleteStaleSessions :execresult
DELETE FROM session
WHERE expires < NOW()
  -- Try to make sure users log in at the start of a session rather than the middle of it 
  OR (
    (expires < NOW() + INTERVAL '20 minutes')
    AND last_seen < NOW() - INTERVAL '5 minutes'
  )
`

func (q *Queries) DeleteStaleSessions(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteStaleSessions)
}

const getActivePatients = `-- name: GetActivePatients :many
SELECT p.id, p.name, p.curr_home_id, p.status, p.journal_url, COALESCE(sl.name, '???') AS species FROM patient AS p
LEFT JOIN species_language AS sl
    ON sl.species_id = p.species_id
WHERE curr_home_id IS NOT NULL
  AND language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetActivePatientsRow struct {
	ID         int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
	JournalUrl pgtype.Text
	Species    string
}

func (q *Queries) GetActivePatients(ctx context.Context, languageID int32) ([]GetActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivePatientsRow
	for rows.Next() {
		var i GetActivePatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppusers = `-- name: GetAppusers :many
SELECT au.id, au.display_name, au.google_sub, au.email, au.logging_consent, au.avatar_url, au.has_gdrive_access, ha.home_id FROM appuser AS au
LEFT JOIN home_appuser AS ha
    ON ha.appuser_id = au.id
ORDER BY au.id
`

type GetAppusersRow struct {
	ID              int32
	DisplayName     string
	GoogleSub       string
	Email           string
	LoggingConsent  pgtype.Timestamptz
	AvatarUrl       pgtype.Text
	HasGdriveAccess bool
	HomeID          pgtype.Int4
}

func (q *Queries) GetAppusers(ctx context.Context) ([]GetAppusersRow, error) {
	rows, err := q.db.Query(ctx, getAppusers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAppusersRow
	for rows.Next() {
		var i GetAppusersRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.GoogleSub,
			&i.Email,
			&i.LoggingConsent,
			&i.AvatarUrl,
			&i.HasGdriveAccess,
			&i.HomeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAppusersForHome = `-- name: GetAppusersForHome :many
SELECT au.id, au.display_name, au.google_sub, au.email, au.logging_consent, au.avatar_url, au.has_gdrive_access
FROM home_appuser AS hau
INNER JOIN appuser AS au
  ON hau.appuser_id = au.id
WHERE home_id = $1
`

func (q *Queries) GetAppusersForHome(ctx context.Context, homeID int32) ([]Appuser, error) {
	rows, err := q.db.Query(ctx, getAppusersForHome, homeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Appuser
	for rows.Next() {
		var i Appuser
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.GoogleSub,
			&i.Email,
			&i.LoggingConsent,
			&i.AvatarUrl,
			&i.HasGdriveAccess,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentPatientsForHome = `-- name: GetCurrentPatientsForHome :many
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.curr_home_id = $1
  AND sl.language_id = $2
ORDER BY p.sort_order, p.id
`

type GetCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetCurrentPatientsForHomeRow struct {
	ID          int32
	SpeciesID   int32
	CurrHomeID  pgtype.Int4
	Name        string
	Status      int32
	JournalUrl  pgtype.Text
	SortOrder   int32
	SpeciesName string
}

func (q *Queries) GetCurrentPatientsForHome(ctx context.Context, arg GetCurrentPatientsForHomeParams) ([]GetCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetCurrentPatientsForHomeRow
		if err := rows.Scan(
			&i.ID,
			&i.SpeciesID,
			&i.CurrHomeID,
			&i.Name,
			&i.Status,
			&i.JournalUrl,
			&i.SortOrder,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForPatient = `-- name: GetEventsForPatient :many
SELECT
    pe.id, pe.patient_id, pe.home_id, pe.note, pe.event_id, pe.time, pe.associated_id, pe.appuser_id,
    h.name AS home_name,
    au.display_name AS user_name,
    au.avatar_url AS avatar_url
FROM patient_event AS pe
JOIN home AS h
  ON h.id = pe.home_id
JOIN appuser AS au
  ON au.id = pe.appuser_id
WHERE pe.patient_id = $1
ORDER BY pe.time
`

type GetEventsForPatientRow struct {
	ID           int32
	PatientID    int32
	HomeID       int32
	Note         string
	EventID      int32
	Time         pgtype.Timestamptz
	AssociatedID pgtype.Int4
	AppuserID    int32
	HomeName     string
	UserName     string
	AvatarUrl    pgtype.Text
}

func (q *Queries) GetEventsForPatient(ctx context.Context, patientID int32) ([]GetEventsForPatientRow, error) {
	rows, err := q.db.Query(ctx, getEventsForPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsForPatientRow
	for rows.Next() {
		var i GetEventsForPatientRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.HomeID,
			&i.Note,
			&i.EventID,
			&i.Time,
			&i.AssociatedID,
			&i.AppuserID,
			&i.HomeName,
			&i.UserName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstEventOfTypeForPatient = `-- name: GetFirstEventOfTypeForPatient :one
SELECT
  pe.time
FROM patient_event AS pe
WHERE pe.patient_id = $1
  AND pe.event_id = $2
ORDER BY pe.time ASC
`

type GetFirstEventOfTypeForPatientParams struct {
	PatientID int32
	EventID   int32
}

func (q *Queries) GetFirstEventOfTypeForPatient(ctx context.Context, arg GetFirstEventOfTypeForPatientParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getFirstEventOfTypeForPatient, arg.PatientID, arg.EventID)
	var time pgtype.Timestamptz
	err := row.Scan(&time)
	return time, err
}

const getFormerPatients = `-- name: GetFormerPatients :many
SELECT p.id, p.name, p.curr_home_id, p.status, COALESCE(sl.name, '???') AS species FROM patient AS p
LEFT JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE curr_home_id IS NULL
  AND sl.language_id = $1
ORDER BY p.id DESC
`

type GetFormerPatientsRow struct {
	ID         int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
	Species    string
}

func (q *Queries) GetFormerPatients(ctx context.Context, languageID int32) ([]GetFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFormerPatientsRow
	for rows.Next() {
		var i GetFormerPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHome = `-- name: GetHome :one
SELECT id, name, capacity FROM home
WHERE id = $1
`

func (q *Queries) GetHome(ctx context.Context, id int32) (Home, error) {
	row := q.db.QueryRow(ctx, getHome, id)
	var i Home
	err := row.Scan(&i.ID, &i.Name, &i.Capacity)
	return i, err
}

const getHomes = `-- name: GetHomes :many
SELECT id, name, capacity FROM home
ORDER BY name
`

func (q *Queries) GetHomes(ctx context.Context) ([]Home, error) {
	rows, err := q.db.Query(ctx, getHomes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Home
	for rows.Next() {
		var i Home
		if err := rows.Scan(&i.ID, &i.Name, &i.Capacity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHomesForUser = `-- name: GetHomesForUser :many
SELECT h.id, h.name, h.capacity FROM home_appuser AS ha
INNER JOIN home AS h
  ON h.id = ha.home_id
WHERE appuser_id = $1
`

func (q *Queries) GetHomesForUser(ctx context.Context, appuserID int32) ([]Home, error) {
	rows, err := q.db.Query(ctx, getHomesForUser, appuserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Home
	for rows.Next() {
		var i Home
		if err := rows.Scan(&i.ID, &i.Name, &i.Capacity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHomesWithDataForUser = `-- name: GetHomesWithDataForUser :many
SELECT h.id, h.name, h.capacity
FROM home AS h
INNER JOIN home_appuser AS hau
  ON hau.home_id = h.id
WHERE appuser_id = $1
`

func (q *Queries) GetHomesWithDataForUser(ctx context.Context, appuserID int32) ([]Home, error) {
	rows, err := q.db.Query(ctx, getHomesWithDataForUser, appuserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Home
	for rows.Next() {
		var i Home
		if err := rows.Scan(&i.ID, &i.Name, &i.Capacity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitations = `-- name: GetInvitations :many
SELECT id, email, expires, created
FROM invitation
WHERE expires > NOW()
ORDER BY created DESC
`

func (q *Queries) GetInvitations(ctx context.Context) ([]Invitation, error) {
	rows, err := q.db.Query(ctx, getInvitations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Invitation
	for rows.Next() {
		var i Invitation
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Expires,
			&i.Created,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNameOfSpecies = `-- name: GetNameOfSpecies :one
SELECT name FROM species_language
WHERE species_id = $1
  AND language_id = $2
`

type GetNameOfSpeciesParams struct {
	SpeciesID  int32
	LanguageID int32
}

func (q *Queries) GetNameOfSpecies(ctx context.Context, arg GetNameOfSpeciesParams) (string, error) {
	row := q.db.QueryRow(ctx, getNameOfSpecies, arg.SpeciesID, arg.LanguageID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getPatient = `-- name: GetPatient :one
SELECT id, species_id, curr_home_id, name, status, journal_url, sort_order FROM patient
WHERE id = $1
`

func (q *Queries) GetPatient(ctx context.Context, id int32) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatient, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
	)
	return i, err
}

const getPatientWithSpecies = `-- name: GetPatientWithSpecies :one
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.id = $1
  AND sl.language_id = $2
`

type GetPatientWithSpeciesParams struct {
	ID         int32
	LanguageID int32
}

type GetPatientWithSpeciesRow struct {
	ID          int32
	SpeciesID   int32
	CurrHomeID  pgtype.Int4
	Name        string
	Status      int32
	JournalUrl  pgtype.Text
	SortOrder   int32
	SpeciesName string
}

func (q *Queries) GetPatientWithSpecies(ctx context.Context, arg GetPatientWithSpeciesParams) (GetPatientWithSpeciesRow, error) {
	row := q.db.QueryRow(ctx, getPatientWithSpecies, arg.ID, arg.LanguageID)
	var i GetPatientWithSpeciesRow
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.SpeciesName,
	)
	return i, err
}

const getPreferredSpecies = `-- name: GetPreferredSpecies :many
SELECT hps.home_id, sl.species_id, sl.name FROM home_preferred_species AS hps
JOIN species_language AS sl USING (species_id)
WHERE language_id = $1
`

type GetPreferredSpeciesRow struct {
	HomeID    int32
	SpeciesID int32
	Name      string
}

func (q *Queries) GetPreferredSpecies(ctx context.Context, languageID int32) ([]GetPreferredSpeciesRow, error) {
	rows, err := q.db.Query(ctx, getPreferredSpecies, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPreferredSpeciesRow
	for rows.Next() {
		var i GetPreferredSpeciesRow
		if err := rows.Scan(&i.HomeID, &i.SpeciesID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreferredSpeciesForHome = `-- name: GetPreferredSpeciesForHome :many
SELECT hps.species_id, sl.name FROM home_preferred_species AS hps
JOIN species_language AS sl USING(species_id)
WHERE hps.home_id = $1
  AND sl.language_id = $2
`

type GetPreferredSpeciesForHomeParams struct {
	HomeID     int32
	LanguageID int32
}

type GetPreferredSpeciesForHomeRow struct {
	SpeciesID int32
	Name      string
}

func (q *Queries) GetPreferredSpeciesForHome(ctx context.Context, arg GetPreferredSpeciesForHomeParams) ([]GetPreferredSpeciesForHomeRow, error) {
	rows, err := q.db.Query(ctx, getPreferredSpeciesForHome, arg.HomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPreferredSpeciesForHomeRow
	for rows.Next() {
		var i GetPreferredSpeciesForHomeRow
		if err := rows.Scan(&i.SpeciesID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT id, appuser_id, expires, last_seen
FROM session
WHERE id = $1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.AppuserID,
		&i.Expires,
		&i.LastSeen,
	)
	return i, err
}

const getSpecies = `-- name: GetSpecies :many
SELECT id, scientific_name FROM species
ORDER BY id
`

func (q *Queries) GetSpecies(ctx context.Context) ([]Species, error) {
	rows, err := q.db.Query(ctx, getSpecies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Species
	for rows.Next() {
		var i Species
		if err := rows.Scan(&i.ID, &i.ScientificName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpeciesLanguage = `-- name: GetSpeciesLanguage :many
SELECT species_id, language_id, name FROM species_language
ORDER BY (species_id, language_id)
`

func (q *Queries) GetSpeciesLanguage(ctx context.Context) ([]SpeciesLanguage, error) {
	rows, err := q.db.Query(ctx, getSpeciesLanguage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpeciesLanguage
	for rows.Next() {
		var i SpeciesLanguage
		if err := rows.Scan(&i.SpeciesID, &i.LanguageID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpeciesWithLanguage = `-- name: GetSpeciesWithLanguage :many
SELECT species_id, name FROM species_language
WHERE language_id = $1
ORDER BY (species_id)
`

type GetSpeciesWithLanguageRow struct {
	SpeciesID int32
	Name      string
}

func (q *Queries) GetSpeciesWithLanguage(ctx context.Context, languageID int32) ([]GetSpeciesWithLanguageRow, error) {
	rows, err := q.db.Query(ctx, getSpeciesWithLanguage, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpeciesWithLanguageRow
	for rows.Next() {
		var i GetSpeciesWithLanguageRow
		if err := rows.Scan(&i.SpeciesID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagName = `-- name: GetTagName :one
SELECT name FROM tag_language
WHERE language_id = $1
  AND tag_id = $2
`

type GetTagNameParams struct {
	LanguageID int32
	TagID      int32
}

func (q *Queries) GetTagName(ctx context.Context, arg GetTagNameParams) (string, error) {
	row := q.db.QueryRow(ctx, getTagName, arg.LanguageID, arg.TagID)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getTags = `-- name: GetTags :many
SELECT id, default_show FROM tag
ORDER BY id
`

func (q *Queries) GetTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.DefaultShow); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForActivePatients = `-- name: GetTagsForActivePatients :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
LEFT JOIN patient AS p
    ON p.id = pt.patient_id
WHERE p.curr_home_id IS NOT NULL
AND tl.language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetTagsForActivePatientsRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForActivePatients(ctx context.Context, languageID int32) ([]GetTagsForActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getTagsForActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForActivePatientsRow
	for rows.Next() {
		var i GetTagsForActivePatientsRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForCurrentPatientsForHome = `-- name: GetTagsForCurrentPatientsForHome :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name
FROM patient_tag AS pt
LEFT JOIN tag_language as tl
  ON tl.tag_id = pt.tag_id
LEFT JOIN patient as p
  ON p.id = pt.patient_id
WHERE p.curr_home_id = $1
  AND tl.language_id = $2
`

type GetTagsForCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetTagsForCurrentPatientsForHomeRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForCurrentPatientsForHome(ctx context.Context, arg GetTagsForCurrentPatientsForHomeParams) ([]GetTagsForCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getTagsForCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetTagsForCurrentPatientsForHomeRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForFormerPatients = `-- name: GetTagsForFormerPatients :many
SELECT pt.patient_id, pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
LEFT JOIN patient AS p
    ON p.id = pt.patient_id
WHERE p.curr_home_id IS NULL
AND tl.language_id = $1
`

type GetTagsForFormerPatientsRow struct {
	PatientID int32
	TagID     int32
	Name      string
}

func (q *Queries) GetTagsForFormerPatients(ctx context.Context, languageID int32) ([]GetTagsForFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getTagsForFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForFormerPatientsRow
	for rows.Next() {
		var i GetTagsForFormerPatientsRow
		if err := rows.Scan(&i.PatientID, &i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsForPatient = `-- name: GetTagsForPatient :many
SELECT pt.tag_id, COALESCE(tl.name, '???') AS name from patient_tag AS pt
LEFT JOIN tag_language AS tl
    ON tl.tag_id = pt.tag_id
WHERE pt.patient_id = $1
  AND tl.language_id = $2
`

type GetTagsForPatientParams struct {
	PatientID  int32
	LanguageID int32
}

type GetTagsForPatientRow struct {
	TagID int32
	Name  string
}

func (q *Queries) GetTagsForPatient(ctx context.Context, arg GetTagsForPatientParams) ([]GetTagsForPatientRow, error) {
	rows, err := q.db.Query(ctx, getTagsForPatient, arg.PatientID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsForPatientRow
	for rows.Next() {
		var i GetTagsForPatientRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsLanguage = `-- name: GetTagsLanguage :many
SELECT tag_id, language_id, name FROM tag_language
ORDER BY (tag_id, language_id)
`

func (q *Queries) GetTagsLanguage(ctx context.Context) ([]TagLanguage, error) {
	rows, err := q.db.Query(ctx, getTagsLanguage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TagLanguage
	for rows.Next() {
		var i TagLanguage
		if err := rows.Scan(&i.TagID, &i.LanguageID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsWithLanguage = `-- name: GetTagsWithLanguage :many
SELECT tag_id, name FROM tag_language
WHERE language_id = $1
ORDER BY (tag_id)
`

type GetTagsWithLanguageRow struct {
	TagID int32
	Name  string
}

func (q *Queries) GetTagsWithLanguage(ctx context.Context, languageID int32) ([]GetTagsWithLanguageRow, error) {
	rows, err := q.db.Query(ctx, getTagsWithLanguage, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsWithLanguageRow
	for rows.Next() {
		var i GetTagsWithLanguageRow
		if err := rows.Scan(&i.TagID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsWithLanguageCheckin = `-- name: GetTagsWithLanguageCheckin :many
SELECT tag_id, name, default_show FROM tag_language
INNER JOIN tag AS t
    ON t.id = tag_language.tag_id
WHERE language_id = $1
ORDER BY (default_show, tag_id) DESC
`

type GetTagsWithLanguageCheckinRow struct {
	TagID       int32
	Name        string
	DefaultShow bool
}

func (q *Queries) GetTagsWithLanguageCheckin(ctx context.Context, languageID int32) ([]GetTagsWithLanguageCheckinRow, error) {
	rows, err := q.db.Query(ctx, getTagsWithLanguageCheckin, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsWithLanguageCheckinRow
	for rows.Next() {
		var i GetTagsWithLanguageCheckinRow
		if err := rows.Scan(&i.TagID, &i.Name, &i.DefaultShow); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT au.id, au.display_name, au.google_sub, au.email, au.logging_consent, au.avatar_url, au.has_gdrive_access, COALESCE(al.language_id, 1) FROM appuser AS au
LEFT JOIN appuser_language AS al
ON au.id = al.appuser_id
WHERE id = $1
`

type GetUserRow struct {
	ID              int32
	DisplayName     string
	GoogleSub       string
	Email           string
	LoggingConsent  pgtype.Timestamptz
	AvatarUrl       pgtype.Text
	HasGdriveAccess bool
	LanguageID      int32
}

func (q *Queries) GetUser(ctx context.Context, id int32) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.GoogleSub,
		&i.Email,
		&i.LoggingConsent,
		&i.AvatarUrl,
		&i.HasGdriveAccess,
		&i.LanguageID,
	)
	return i, err
}

const insertHome = `-- name: InsertHome :exec
INSERT INTO home (name)
VALUES ($1)
`

func (q *Queries) InsertHome(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, insertHome, name)
	return err
}

const insertInvitation = `-- name: InsertInvitation :exec
INSERT INTO invitation (
  id,
  email,
  expires,
  created
) VALUES (
  $1,
  $2,
  $3,
  $4
)
`

type InsertInvitationParams struct {
	ID      string
	Email   pgtype.Text
	Expires pgtype.Timestamptz
	Created pgtype.Timestamptz
}

func (q *Queries) InsertInvitation(ctx context.Context, arg InsertInvitationParams) error {
	_, err := q.db.Exec(ctx, insertInvitation,
		arg.ID,
		arg.Email,
		arg.Expires,
		arg.Created,
	)
	return err
}

const insertSession = `-- name: InsertSession :exec
INSERT INTO session (id, appuser_id, expires, last_seen)
VALUES ($1, $2, $3, NOW())
`

type InsertSessionParams struct {
	ID        string
	AppuserID int32
	Expires   pgtype.Timestamptz
}

func (q *Queries) InsertSession(ctx context.Context, arg InsertSessionParams) error {
	_, err := q.db.Exec(ctx, insertSession, arg.ID, arg.AppuserID, arg.Expires)
	return err
}

const movePatient = `-- name: MovePatient :exec
UPDATE patient
SET curr_home_id = $2
WHERE id = $1
`

type MovePatientParams struct {
	ID         int32
	CurrHomeID pgtype.Int4
}

func (q *Queries) MovePatient(ctx context.Context, arg MovePatientParams) error {
	_, err := q.db.Exec(ctx, movePatient, arg.ID, arg.CurrHomeID)
	return err
}

const removeHomesForAppuser = `-- name: RemoveHomesForAppuser :exec
DELETE
FROM home_appuser
WHERE appuser_id = $1
`

func (q *Queries) RemoveHomesForAppuser(ctx context.Context, appuserID int32) error {
	_, err := q.db.Exec(ctx, removeHomesForAppuser, appuserID)
	return err
}

const removeUserFromHome = `-- name: RemoveUserFromHome :exec
DELETE FROM home_appuser
WHERE home_id = $1
  AND appuser_id = $2
`

type RemoveUserFromHomeParams struct {
	HomeID    int32
	AppuserID int32
}

func (q *Queries) RemoveUserFromHome(ctx context.Context, arg RemoveUserFromHomeParams) error {
	_, err := q.db.Exec(ctx, removeUserFromHome, arg.HomeID, arg.AppuserID)
	return err
}

const revokeAllOtherSessionsForUser = `-- name: RevokeAllOtherSessionsForUser :execresult
DELETE FROM session
WHERE id != $1
  AND appuser_id == $2
`

type RevokeAllOtherSessionsForUserParams struct {
	ID        string
	AppuserID int32
}

func (q *Queries) RevokeAllOtherSessionsForUser(ctx context.Context, arg RevokeAllOtherSessionsForUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, revokeAllOtherSessionsForUser, arg.ID, arg.AppuserID)
}

const revokeAllSessionsForUser = `-- name: RevokeAllSessionsForUser :execresult
DELETE FROM session
WHERE appuser_id = $1
`

func (q *Queries) RevokeAllSessionsForUser(ctx context.Context, appuserID int32) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, revokeAllSessionsForUser, appuserID)
}

const revokeLoggingConsent = `-- name: RevokeLoggingConsent :exec
UPDATE appuser SET logging_consent = NULL
WHERE id = $1
`

func (q *Queries) RevokeLoggingConsent(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, revokeLoggingConsent, id)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
DELETE FROM session
WHERE id = $1
`

func (q *Queries) RevokeSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, revokeSession, id)
	return err
}

const scrubAppuser = `-- name: ScrubAppuser :exec
UPDATE appuser SET
  display_name = 'Deleted user (id = ' || id || ')',
  google_sub = '',
  email = '',
  logging_consent = NULL,
  avatar_url = '',
  has_gdrive_access = FALSE 
WHERE id = $1
`

func (q *Queries) ScrubAppuser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, scrubAppuser, id)
	return err
}

const setEventNote = `-- name: SetEventNote :exec
UPDATE patient_event
SET note = $2
WHERE id = $1
`

type SetEventNoteParams struct {
	ID   int32
	Note string
}

func (q *Queries) SetEventNote(ctx context.Context, arg SetEventNoteParams) error {
	_, err := q.db.Exec(ctx, setEventNote, arg.ID, arg.Note)
	return err
}

const setHomeCapacity = `-- name: SetHomeCapacity :exec
UPDATE home
SET capacity = $2
WHERE id = $1
`

type SetHomeCapacityParams struct {
	ID       int32
	Capacity int32
}

func (q *Queries) SetHomeCapacity(ctx context.Context, arg SetHomeCapacityParams) error {
	_, err := q.db.Exec(ctx, setHomeCapacity, arg.ID, arg.Capacity)
	return err
}

const setLoggingConsent = `-- name: SetLoggingConsent :exec
UPDATE appuser SET logging_consent = NOW() + $2::INT * INTERVAL '1 day'
WHERE id = $1
`

type SetLoggingConsentParams struct {
	ID     int32
	Period int32
}

func (q *Queries) SetLoggingConsent(ctx context.Context, arg SetLoggingConsentParams) error {
	_, err := q.db.Exec(ctx, setLoggingConsent, arg.ID, arg.Period)
	return err
}

const setPatientJournal = `-- name: SetPatientJournal :exec
UPDATE patient
SET journal_url = $2
WHERE id = $1
`

type SetPatientJournalParams struct {
	ID         int32
	JournalUrl pgtype.Text
}

func (q *Queries) SetPatientJournal(ctx context.Context, arg SetPatientJournalParams) error {
	_, err := q.db.Exec(ctx, setPatientJournal, arg.ID, arg.JournalUrl)
	return err
}

const setPatientName = `-- name: SetPatientName :exec
UPDATE patient
SET name = $2
WHERE id = $1
`

type SetPatientNameParams struct {
	ID   int32
	Name string
}

func (q *Queries) SetPatientName(ctx context.Context, arg SetPatientNameParams) error {
	_, err := q.db.Exec(ctx, setPatientName, arg.ID, arg.Name)
	return err
}

const setPatientStatus = `-- name: SetPatientStatus :exec
UPDATE patient
SET status = $2
WHERE id = $1
`

type SetPatientStatusParams struct {
	ID     int32
	Status int32
}

func (q *Queries) SetPatientStatus(ctx context.Context, arg SetPatientStatusParams) error {
	_, err := q.db.Exec(ctx, setPatientStatus, arg.ID, arg.Status)
	return err
}

const setUserGDriveAccess = `-- name: SetUserGDriveAccess :exec
UPDATE appuser
SET has_gdrive_access = $2
WHERE id = $1
`

type SetUserGDriveAccessParams struct {
	ID              int32
	HasGdriveAccess bool
}

func (q *Queries) SetUserGDriveAccess(ctx context.Context, arg SetUserGDriveAccessParams) error {
	_, err := q.db.Exec(ctx, setUserGDriveAccess, arg.ID, arg.HasGdriveAccess)
	return err
}

const setUserLanguage = `-- name: SetUserLanguage :exec
INSERT INTO appuser_language (appuser_id, language_id)
VALUES ($1, $2)
ON CONFLICT (appuser_id) DO UPDATE
    SET language_id = EXCLUDED.language_id
`

type SetUserLanguageParams struct {
	AppuserID  int32
	LanguageID int32
}

func (q *Queries) SetUserLanguage(ctx context.Context, arg SetUserLanguageParams) error {
	_, err := q.db.Exec(ctx, setUserLanguage, arg.AppuserID, arg.LanguageID)
	return err
}

const updateHomeName = `-- name: UpdateHomeName :exec
UPDATE home
SET name = $2
WHERE id = $1
`

type UpdateHomeNameParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdateHomeName(ctx context.Context, arg UpdateHomeNameParams) error {
	_, err := q.db.Exec(ctx, updateHomeName, arg.ID, arg.Name)
	return err
}

const updatePatientSortOrder = `-- name: UpdatePatientSortOrder :exec
UPDATE patient as p
SET sort_order = v.sort_order
FROM (
  SELECT UNNEST($1::int[]) AS id,
         UNNEST($2::int[]) AS sort_order
) AS v
WHERE p.id = v.id
`

type UpdatePatientSortOrderParams struct {
	Ids    []int32
	Orders []int32
}

func (q *Queries) UpdatePatientSortOrder(ctx context.Context, arg UpdatePatientSortOrderParams) error {
	_, err := q.db.Exec(ctx, updatePatientSortOrder, arg.Ids, arg.Orders)
	return err
}

const updatePreferredSpeciesSortOrder = `-- name: UpdatePreferredSpeciesSortOrder :exec
UPDATE home_preferred_species as hps
SET sort_order = v.sort_order
FROM (
  SELECT UNNEST($2::int[]) AS id,
         UNNEST($3::int[]) AS sort_order
) AS v
WHERE hps.species_id = v.id
  AND hps.home_id = $1
`

type UpdatePreferredSpeciesSortOrderParams struct {
	HomeID    int32
	SpeciesID []int32
	Orders    []int32
}

func (q *Queries) UpdatePreferredSpeciesSortOrder(ctx context.Context, arg UpdatePreferredSpeciesSortOrderParams) error {
	_, err := q.db.Exec(ctx, updatePreferredSpeciesSortOrder, arg.HomeID, arg.SpeciesID, arg.Orders)
	return err
}

const updateSessionLastSeen = `-- name: UpdateSessionLastSeen :exec
UPDATE session
SET last_seen = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSessionLastSeen(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, updateSessionLastSeen, id)
	return err
}

const updateTagDefaultShown = `-- name: UpdateTagDefaultShown :exec
UPDATE tag SET default_show = $1
WHERE id = $2
`

type UpdateTagDefaultShownParams struct {
	DefaultShow bool
	ID          int32
}

func (q *Queries) UpdateTagDefaultShown(ctx context.Context, arg UpdateTagDefaultShownParams) error {
	_, err := q.db.Exec(ctx, updateTagDefaultShown, arg.DefaultShow, arg.ID)
	return err
}

const upsertSpeciesLanguage = `-- name: UpsertSpeciesLanguage :exec
INSERT INTO species_language (species_id, language_id, name)
VALUES ($1, $2, $3)
ON CONFLICT (species_id, language_id) DO UPDATE
    SET name = EXCLUDED.name
`

type UpsertSpeciesLanguageParams struct {
	SpeciesID  int32
	LanguageID int32
	Name       string
}

func (q *Queries) UpsertSpeciesLanguage(ctx context.Context, arg UpsertSpeciesLanguageParams) error {
	_, err := q.db.Exec(ctx, upsertSpeciesLanguage, arg.SpeciesID, arg.LanguageID, arg.Name)
	return err
}

const upsertTagLanguage = `-- name: UpsertTagLanguage :exec
INSERT INTO tag_language (tag_id, language_id, name)
VALUES ($1, $2, $3)
ON CONFLICT (tag_id, language_id) DO UPDATE
    SET name = EXCLUDED.name
`

type UpsertTagLanguageParams struct {
	TagID      int32
	LanguageID int32
	Name       string
}

func (q *Queries) UpsertTagLanguage(ctx context.Context, arg UpsertTagLanguageParams) error {
	_, err := q.db.Exec(ctx, upsertTagLanguage, arg.TagID, arg.LanguageID, arg.Name)
	return err
}

const upsertUser = `-- name: UpsertUser :one
INSERT INTO appuser (display_name, google_sub, email, avatar_url)
VALUES ($1, $2, $3, $4)
ON CONFLICT (google_sub) DO UPDATE
    SET display_name = EXCLUDED.display_name,
        email        = EXCLUDED.email,
        avatar_url   = EXCLUDED.avatar_url
RETURNING id
`

type UpsertUserParams struct {
	DisplayName string
	GoogleSub   string
	Email       string
	AvatarUrl   pgtype.Text
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.DisplayName,
		arg.GoogleSub,
		arg.Email,
		arg.AvatarUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}
