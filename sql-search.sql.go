// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-search.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSearchUpdatedTime = `-- name: GetSearchUpdatedTime :one
SELECT updated
FROM search
WHERE ns = $1
  AND associated_id = $2
`

type GetSearchUpdatedTimeParams struct {
	Namespace    string
	AssociatedID int32
}

func (q *Queries) GetSearchUpdatedTime(ctx context.Context, arg GetSearchUpdatedTimeParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getSearchUpdatedTime, arg.Namespace, arg.AssociatedID)
	var updated pgtype.Timestamptz
	err := row.Scan(&updated)
	return updated, err
}

const search = `-- name: Search :many
WITH q AS (
  SELECT websearch_to_tsquery($3, $4) AS qry
)
SELECT
	(ts_rank(fts_header, q.qry) + ts_rank(fts_body, q.qry))::DOUBLE PRECISION AS rank,
	s.header,
	ts_headline('norwegian', s.header, q.qry, 'StartSel=[START],StopSel=[STOP],HighlightAll=true')::TEXT AS header_headline,
	ts_headline('norwegian', s.body, q.qry, 'StartSel=[START],StopSel=[STOP],MaxFragments=5,MinWords=3,MaxWords=10')::TEXT AS body_headline,
	s.associated_id,
	s.updated
FROM search AS s, q
WHERE (
	   q.qry @@s.fts_body
	OR q.qry @@s.fts_header
)
ORDER BY RANK desc
LIMIT $2
OFFSET $1
`

type SearchParams struct {
	Offset pgtype.Int4
	Limit  pgtype.Int4
	Lang   string
	Query  string
}

type SearchRow struct {
	Rank           float64
	Header         pgtype.Text
	HeaderHeadline string
	BodyHeadline   string
	AssociatedID   int32
	Updated        pgtype.Timestamptz
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.Query(ctx, search,
		arg.Offset,
		arg.Limit,
		arg.Lang,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchRow
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.Rank,
			&i.Header,
			&i.HeaderHeadline,
			&i.BodyHeadline,
			&i.AssociatedID,
			&i.Updated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSearchEntry = `-- name: UpsertSearchEntry :exec
INSERT INTO search (ns, associated_id, updated, header, body, lang)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
ON CONFLICT (ns, associated_id) DO UPDATE SET
    updated = EXCLUDED.updated,
    header  = EXCLUDED.header,
    body    = EXCLUDED.body,
    lang    = EXCLUDED.lang
`

type UpsertSearchEntryParams struct {
	Namespace    string
	AssociatedID int32
	Updated      pgtype.Timestamptz
	Header       pgtype.Text
	Body         pgtype.Text
	Lang         interface{}
}

func (q *Queries) UpsertSearchEntry(ctx context.Context, arg UpsertSearchEntryParams) error {
	_, err := q.db.Exec(ctx, upsertSearchEntry,
		arg.Namespace,
		arg.AssociatedID,
		arg.Updated,
		arg.Header,
		arg.Body,
		arg.Lang,
	)
	return err
}
