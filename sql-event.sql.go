// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-event.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPatientEvent = `-- name: AddPatientEvent :one
INSERT INTO patient_event (patient_id, home_id, event_id, associated_id, note, appuser_id, time)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type AddPatientEventParams struct {
	PatientID    int32
	HomeID       int32
	EventID      int32
	AssociatedID pgtype.Int4
	Note         string
	AppuserID    int32
	Time         pgtype.Timestamptz
}

func (q *Queries) AddPatientEvent(ctx context.Context, arg AddPatientEventParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatientEvent,
		arg.PatientID,
		arg.HomeID,
		arg.EventID,
		arg.AssociatedID,
		arg.Note,
		arg.AppuserID,
		arg.Time,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteEventsCreatedByUser = `-- name: DeleteEventsCreatedByUser :exec
DELETE
FROM patient_event
WHERE appuser_id = $1
`

func (q *Queries) DeleteEventsCreatedByUser(ctx context.Context, appuserID int32) error {
	_, err := q.db.Exec(ctx, deleteEventsCreatedByUser, appuserID)
	return err
}

const getEventsForPatient = `-- name: GetEventsForPatient :many
SELECT
    pe.id, pe.patient_id, pe.home_id, pe.note, pe.event_id, pe.time, pe.associated_id, pe.appuser_id,
    h.name AS home_name,
    au.display_name AS user_name,
    au.avatar_url AS avatar_url
FROM patient_event AS pe
JOIN home AS h
  ON h.id = pe.home_id
JOIN appuser AS au
  ON au.id = pe.appuser_id
WHERE pe.patient_id = $1
ORDER BY pe.time
`

type GetEventsForPatientRow struct {
	ID           int32
	PatientID    int32
	HomeID       int32
	Note         string
	EventID      int32
	Time         pgtype.Timestamptz
	AssociatedID pgtype.Int4
	AppuserID    int32
	HomeName     string
	UserName     string
	AvatarUrl    pgtype.Text
}

func (q *Queries) GetEventsForPatient(ctx context.Context, patientID int32) ([]GetEventsForPatientRow, error) {
	rows, err := q.db.Query(ctx, getEventsForPatient, patientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsForPatientRow
	for rows.Next() {
		var i GetEventsForPatientRow
		if err := rows.Scan(
			&i.ID,
			&i.PatientID,
			&i.HomeID,
			&i.Note,
			&i.EventID,
			&i.Time,
			&i.AssociatedID,
			&i.AppuserID,
			&i.HomeName,
			&i.UserName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstEventOfTypeForPatient = `-- name: GetFirstEventOfTypeForPatient :one
SELECT
  pe.time
FROM patient_event AS pe
WHERE pe.patient_id = $1
  AND pe.event_id = $2
ORDER BY pe.time ASC
LIMIT 1
`

type GetFirstEventOfTypeForPatientParams struct {
	PatientID int32
	EventID   int32
}

func (q *Queries) GetFirstEventOfTypeForPatient(ctx context.Context, arg GetFirstEventOfTypeForPatientParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getFirstEventOfTypeForPatient, arg.PatientID, arg.EventID)
	var time pgtype.Timestamptz
	err := row.Scan(&time)
	return time, err
}

const setEventNote = `-- name: SetEventNote :exec
UPDATE patient_event
SET note = $2
WHERE id = $1
`

type SetEventNoteParams struct {
	ID   int32
	Note string
}

func (q *Queries) SetEventNote(ctx context.Context, arg SetEventNoteParams) error {
	_, err := q.db.Exec(ctx, setEventNote, arg.ID, arg.Note)
	return err
}
