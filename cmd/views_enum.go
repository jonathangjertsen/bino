// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.1

// Built By: go install

package main

import (
	"errors"
	"fmt"
)

const (
	// AvailabilityAvailableIndefinitely is a Availability of type AvailableIndefinitely.
	AvailabilityAvailableIndefinitely Availability = 0
	// AvailabilityAvailableUntil is a Availability of type AvailableUntil.
	AvailabilityAvailableUntil Availability = 1
	// AvailabilityUnavailableUntil is a Availability of type UnavailableUntil.
	AvailabilityUnavailableUntil Availability = 2
	// AvailabilityUnavailableIndefinitely is a Availability of type UnavailableIndefinitely.
	AvailabilityUnavailableIndefinitely Availability = 3
)

var ErrInvalidAvailability = errors.New("not a valid Availability")

const _AvailabilityName = "AvailableIndefinitelyAvailableUntilUnavailableUntilUnavailableIndefinitely"

// AvailabilityValues returns a list of the values for Availability
func AvailabilityValues() []Availability {
	return []Availability{
		AvailabilityAvailableIndefinitely,
		AvailabilityAvailableUntil,
		AvailabilityUnavailableUntil,
		AvailabilityUnavailableIndefinitely,
	}
}

var _AvailabilityMap = map[Availability]string{
	AvailabilityAvailableIndefinitely:   _AvailabilityName[0:21],
	AvailabilityAvailableUntil:          _AvailabilityName[21:35],
	AvailabilityUnavailableUntil:        _AvailabilityName[35:51],
	AvailabilityUnavailableIndefinitely: _AvailabilityName[51:74],
}

// String implements the Stringer interface.
func (x Availability) String() string {
	if str, ok := _AvailabilityMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Availability(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Availability) IsValid() bool {
	_, ok := _AvailabilityMap[x]
	return ok
}

var _AvailabilityValue = map[string]Availability{
	_AvailabilityName[0:21]:  AvailabilityAvailableIndefinitely,
	_AvailabilityName[21:35]: AvailabilityAvailableUntil,
	_AvailabilityName[35:51]: AvailabilityUnavailableUntil,
	_AvailabilityName[51:74]: AvailabilityUnavailableIndefinitely,
}

// ParseAvailability attempts to convert a string to a Availability.
func ParseAvailability(name string) (Availability, error) {
	if x, ok := _AvailabilityValue[name]; ok {
		return x, nil
	}
	return Availability(0), fmt.Errorf("%s is %w", name, ErrInvalidAvailability)
}

const (
	// MatchTypeJournal is a MatchType of type journal.
	MatchTypeJournal MatchType = "journal"
	// MatchTypePatient is a MatchType of type patient.
	MatchTypePatient MatchType = "patient"
)

var ErrInvalidMatchType = errors.New("not a valid MatchType")

// MatchTypeValues returns a list of the values for MatchType
func MatchTypeValues() []MatchType {
	return []MatchType{
		MatchTypeJournal,
		MatchTypePatient,
	}
}

// String implements the Stringer interface.
func (x MatchType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x MatchType) IsValid() bool {
	_, err := ParseMatchType(string(x))
	return err == nil
}

var _MatchTypeValue = map[string]MatchType{
	"journal": MatchTypeJournal,
	"patient": MatchTypePatient,
}

// ParseMatchType attempts to convert a string to a MatchType.
func ParseMatchType(name string) (MatchType, error) {
	if x, ok := _MatchTypeValue[name]; ok {
		return x, nil
	}
	return MatchType(""), fmt.Errorf("%s is %w", name, ErrInvalidMatchType)
}
