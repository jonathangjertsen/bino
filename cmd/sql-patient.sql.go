// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: sql-patient.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPatient = `-- name: AddPatient :one
INSERT INTO patient (species_id, name, curr_home_id, status, time_checkin)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id
`

type AddPatientParams struct {
	SpeciesID  int32
	Name       string
	CurrHomeID pgtype.Int4
	Status     int32
}

func (q *Queries) AddPatient(ctx context.Context, arg AddPatientParams) (int32, error) {
	row := q.db.QueryRow(ctx, addPatient,
		arg.SpeciesID,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPatients = `-- name: AddPatients :many
INSERT INTO patient (species_id, name, curr_home_id, status, journal_url, time_checkin)
SELECT UNNEST($1::int[]),
       UNNEST($2::text[]),
       UNNEST($3::int[]),
       UNNEST($4::int[]),
       UNNEST($5::text[]),
       NOW()
RETURNING id
`

type AddPatientsParams struct {
	Species    []int32
	Name       []string
	CurrHomeID []int32
	Status     []int32
	JournalUrl []string
}

func (q *Queries) AddPatients(ctx context.Context, arg AddPatientsParams) ([]int32, error) {
	rows, err := q.db.Query(ctx, addPatients,
		arg.Species,
		arg.Name,
		arg.CurrHomeID,
		arg.Status,
		arg.JournalUrl,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const checkoutPatient = `-- name: CheckoutPatient :exec
UPDATE patient
SET time_checkout = $2
WHERE id = $1
`

type CheckoutPatientParams struct {
	ID           int32
	TimeCheckout pgtype.Timestamptz
}

func (q *Queries) CheckoutPatient(ctx context.Context, arg CheckoutPatientParams) error {
	_, err := q.db.Exec(ctx, checkoutPatient, arg.ID, arg.TimeCheckout)
	return err
}

const getActivePatients = `-- name: GetActivePatients :many
SELECT
  p.id,
  p.name,
  p.curr_home_id,
  p.status,
  p.journal_url,
  p.time_checkin,
  p.time_checkout,
  COALESCE(sl.name, '???') AS species
FROM patient AS p
LEFT JOIN species_language AS sl
    ON sl.species_id = p.species_id
WHERE curr_home_id IS NOT NULL
  AND language_id = $1
ORDER BY p.curr_home_id, p.sort_order, p.id
`

type GetActivePatientsRow struct {
	ID           int32
	Name         string
	CurrHomeID   pgtype.Int4
	Status       int32
	JournalUrl   pgtype.Text
	TimeCheckin  pgtype.Timestamptz
	TimeCheckout pgtype.Timestamptz
	Species      string
}

func (q *Queries) GetActivePatients(ctx context.Context, languageID int32) ([]GetActivePatientsRow, error) {
	rows, err := q.db.Query(ctx, getActivePatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActivePatientsRow
	for rows.Next() {
		var i GetActivePatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrentPatientsForHome = `-- name: GetCurrentPatientsForHome :many
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, p.time_checkin, p.time_checkout, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.curr_home_id = $1
  AND sl.language_id = $2
ORDER BY p.sort_order, p.id
`

type GetCurrentPatientsForHomeParams struct {
	CurrHomeID pgtype.Int4
	LanguageID int32
}

type GetCurrentPatientsForHomeRow struct {
	ID           int32
	SpeciesID    int32
	CurrHomeID   pgtype.Int4
	Name         string
	Status       int32
	JournalUrl   pgtype.Text
	SortOrder    int32
	TimeCheckin  pgtype.Timestamptz
	TimeCheckout pgtype.Timestamptz
	SpeciesName  string
}

func (q *Queries) GetCurrentPatientsForHome(ctx context.Context, arg GetCurrentPatientsForHomeParams) ([]GetCurrentPatientsForHomeRow, error) {
	rows, err := q.db.Query(ctx, getCurrentPatientsForHome, arg.CurrHomeID, arg.LanguageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrentPatientsForHomeRow
	for rows.Next() {
		var i GetCurrentPatientsForHomeRow
		if err := rows.Scan(
			&i.ID,
			&i.SpeciesID,
			&i.CurrHomeID,
			&i.Name,
			&i.Status,
			&i.JournalUrl,
			&i.SortOrder,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.SpeciesName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFormerPatients = `-- name: GetFormerPatients :many
SELECT
  p.id,
  p.name,
  p.curr_home_id,
  p.status,
  p.journal_url,
  p.time_checkin,
  p.time_checkout,
  COALESCE(sl.name, '???') AS species
FROM patient AS p
LEFT JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE curr_home_id IS NULL
  AND sl.language_id = $1
ORDER BY p.id DESC
`

type GetFormerPatientsRow struct {
	ID           int32
	Name         string
	CurrHomeID   pgtype.Int4
	Status       int32
	JournalUrl   pgtype.Text
	TimeCheckin  pgtype.Timestamptz
	TimeCheckout pgtype.Timestamptz
	Species      string
}

func (q *Queries) GetFormerPatients(ctx context.Context, languageID int32) ([]GetFormerPatientsRow, error) {
	rows, err := q.db.Query(ctx, getFormerPatients, languageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFormerPatientsRow
	for rows.Next() {
		var i GetFormerPatientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CurrHomeID,
			&i.Status,
			&i.JournalUrl,
			&i.TimeCheckin,
			&i.TimeCheckout,
			&i.Species,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPatient = `-- name: GetPatient :one
SELECT id, species_id, curr_home_id, name, status, journal_url, sort_order, time_checkin, time_checkout FROM patient
WHERE id = $1
`

func (q *Queries) GetPatient(ctx context.Context, id int32) (Patient, error) {
	row := q.db.QueryRow(ctx, getPatient, id)
	var i Patient
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.TimeCheckin,
		&i.TimeCheckout,
	)
	return i, err
}

const getPatientWithSpecies = `-- name: GetPatientWithSpecies :one
SELECT p.id, p.species_id, p.curr_home_id, p.name, p.status, p.journal_url, p.sort_order, p.time_checkin, p.time_checkout, sl.name AS species_name FROM patient AS p
JOIN species_language AS sl
  ON sl.species_id = p.species_id
WHERE p.id = $1
  AND sl.language_id = $2
`

type GetPatientWithSpeciesParams struct {
	ID         int32
	LanguageID int32
}

type GetPatientWithSpeciesRow struct {
	ID           int32
	SpeciesID    int32
	CurrHomeID   pgtype.Int4
	Name         string
	Status       int32
	JournalUrl   pgtype.Text
	SortOrder    int32
	TimeCheckin  pgtype.Timestamptz
	TimeCheckout pgtype.Timestamptz
	SpeciesName  string
}

func (q *Queries) GetPatientWithSpecies(ctx context.Context, arg GetPatientWithSpeciesParams) (GetPatientWithSpeciesRow, error) {
	row := q.db.QueryRow(ctx, getPatientWithSpecies, arg.ID, arg.LanguageID)
	var i GetPatientWithSpeciesRow
	err := row.Scan(
		&i.ID,
		&i.SpeciesID,
		&i.CurrHomeID,
		&i.Name,
		&i.Status,
		&i.JournalUrl,
		&i.SortOrder,
		&i.TimeCheckin,
		&i.TimeCheckout,
		&i.SpeciesName,
	)
	return i, err
}

const getPatientsByJournalURL = `-- name: GetPatientsByJournalURL :many
SELECT
  p.id
FROM patient AS p
WHERE p.journal_url LIKE CONCAT('%', $1::TEXT, '%')
`

func (q *Queries) GetPatientsByJournalURL(ctx context.Context, lookup string) ([]int32, error) {
	rows, err := q.db.Query(ctx, getPatientsByJournalURL, lookup)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const movePatient = `-- name: MovePatient :exec
UPDATE patient
SET curr_home_id = $2
WHERE id = $1
`

type MovePatientParams struct {
	ID         int32
	CurrHomeID pgtype.Int4
}

func (q *Queries) MovePatient(ctx context.Context, arg MovePatientParams) error {
	_, err := q.db.Exec(ctx, movePatient, arg.ID, arg.CurrHomeID)
	return err
}

const setPatientJournal = `-- name: SetPatientJournal :execresult
UPDATE patient
SET journal_url = $2
WHERE id = $1
`

type SetPatientJournalParams struct {
	ID         int32
	JournalUrl pgtype.Text
}

func (q *Queries) SetPatientJournal(ctx context.Context, arg SetPatientJournalParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, setPatientJournal, arg.ID, arg.JournalUrl)
}

const setPatientName = `-- name: SetPatientName :exec
UPDATE patient
SET name = $2
WHERE id = $1
`

type SetPatientNameParams struct {
	ID   int32
	Name string
}

func (q *Queries) SetPatientName(ctx context.Context, arg SetPatientNameParams) error {
	_, err := q.db.Exec(ctx, setPatientName, arg.ID, arg.Name)
	return err
}

const setPatientStatus = `-- name: SetPatientStatus :exec
UPDATE patient
SET status = $2
WHERE id = $1
`

type SetPatientStatusParams struct {
	ID     int32
	Status int32
}

func (q *Queries) SetPatientStatus(ctx context.Context, arg SetPatientStatusParams) error {
	_, err := q.db.Exec(ctx, setPatientStatus, arg.ID, arg.Status)
	return err
}

const updatePatientSortOrder = `-- name: UpdatePatientSortOrder :exec
UPDATE patient as p
SET sort_order = v.sort_order
FROM (
  SELECT UNNEST($1::int[]) AS id,
         UNNEST($2::int[]) AS sort_order
) AS v
WHERE p.id = v.id
`

type UpdatePatientSortOrderParams struct {
	Ids    []int32
	Orders []int32
}

func (q *Queries) UpdatePatientSortOrder(ctx context.Context, arg UpdatePatientSortOrderParams) error {
	_, err := q.db.Exec(ctx, updatePatientSortOrder, arg.Ids, arg.Orders)
	return err
}
