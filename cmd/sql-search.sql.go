// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sql-search.sql

package main

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSearchEntry = `-- name: DeleteSearchEntry :exec
DELETE
FROM search
WHERE ns = $1
  AND associated_url = $2
`

type DeleteSearchEntryParams struct {
	Namespace     string
	AssociatedUrl pgtype.Text
}

func (q *Queries) DeleteSearchEntry(ctx context.Context, arg DeleteSearchEntryParams) error {
	_, err := q.db.Exec(ctx, deleteSearchEntry, arg.Namespace, arg.AssociatedUrl)
	return err
}

const getSearchUpdatedTime = `-- name: GetSearchUpdatedTime :one
SELECT updated
FROM search
WHERE ns = $1
  AND associated_url = $2
`

type GetSearchUpdatedTimeParams struct {
	Namespace     string
	AssociatedUrl pgtype.Text
}

func (q *Queries) GetSearchUpdatedTime(ctx context.Context, arg GetSearchUpdatedTimeParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getSearchUpdatedTime, arg.Namespace, arg.AssociatedUrl)
	var updated pgtype.Timestamptz
	err := row.Scan(&updated)
	return updated, err
}

const searchAdvanced = `-- name: SearchAdvanced :many
WITH q AS (
  SELECT websearch_to_tsquery($8::regconfig, $9::text) AS qry
)
SELECT
  i.r_fts_header, i.r_fts_body, i.r_sim_header, i.r_sim_body, i.r_ilike_header, i.r_ilike_body, i.r_recency, i.header, i.body, i.header_headline, i.body_headline, i.ns, i.associated_url, i.created, i.updated, i.extra_data,
  (
      i.r_fts_header
    + i.r_fts_body
    + i.r_sim_header
    + i.r_sim_body
    + i.r_ilike_header
    + i.r_ilike_body
    + i.r_recency
  )::real AS rank
FROM (
  SELECT
    ($1::real   * ts_rank(s.fts_header, q.qry))::real AS r_fts_header,
    ($2::real     * ts_rank(s.fts_body,   q.qry))::real AS r_fts_body,
    ($3::real   * f.sim_header)::real                 AS r_sim_header,
    ($4::real     * f.sim_body)::real                   AS r_sim_body,
    ($5::real * f.ilike_header)::real               AS r_ilike_header,
    ($6::real   * f.ilike_body)::real                 AS r_ilike_body,
    ($7::real      * f.recency)::real                    AS r_recency,
    COALESCE(s.header, '') AS header,
    COALESCE(s.body, '') AS body,
    ts_headline($8::regconfig, s.header, q.qry, 'StartSel=[START],StopSel=[STOP],HighlightAll=true')::text AS header_headline,
    ts_headline($8::regconfig, s.body,   q.qry, 'StartSel=[START],StopSel=[STOP],MaxFragments=5,MinWords=3,MaxWords=10,FragmentDelimiter=[CUT]')::text AS body_headline,
    s.ns,
    s.associated_url,
    s.created,
    s.updated,
    s.extra_data
  FROM search s
  CROSS JOIN q
  CROSS JOIN LATERAL (
    SELECT
      similarity(lower(s.header), lower($9)) AS sim_header,
      similarity(lower(s.body),   lower($9)) AS sim_body,
      CASE WHEN s.header ILIKE ('%' || $9 || '%') THEN 1 ELSE 0 END AS ilike_header,
      CASE WHEN s.body   ILIKE ('%' || $9 || '%') THEN 1 ELSE 0 END AS ilike_body,
      exp(
        - GREATEST(0, EXTRACT(EPOCH FROM (now() - s.created))) /
          ($10::real * 86400.0)
      ) AS recency
  ) f
  WHERE search_match_advanced(
    s,
    q.qry,
    $9,
    $11::real,
    $12::timestamptz,
    $13::timestamptz,
    $14::timestamptz,
    $15::timestamptz
  )
) i
ORDER BY rank DESC
LIMIT $17
OFFSET $16
`

type SearchAdvancedParams struct {
	WFtsHeader          float32
	WFtsBody            float32
	WSimHeader          float32
	WSimBody            float32
	WIlikeHeader        float32
	WIlikeBody          float32
	WRecency            float32
	Lang                string
	Query               string
	RecencyHalfLifeDays float32
	Simthreshold        float32
	MinCreated          pgtype.Timestamptz
	MaxCreated          pgtype.Timestamptz
	MinUpdated          pgtype.Timestamptz
	MaxUpdated          pgtype.Timestamptz
	Offset              int32
	Limit               int32
}

type SearchAdvancedRow struct {
	RFtsHeader     float32
	RFtsBody       float32
	RSimHeader     float32
	RSimBody       float32
	RIlikeHeader   float32
	RIlikeBody     float32
	RRecency       float32
	Header         string
	Body           string
	HeaderHeadline string
	BodyHeadline   string
	Ns             string
	AssociatedUrl  pgtype.Text
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	ExtraData      pgtype.Text
	Rank           float32
}

func (q *Queries) SearchAdvanced(ctx context.Context, arg SearchAdvancedParams) ([]SearchAdvancedRow, error) {
	rows, err := q.db.Query(ctx, searchAdvanced,
		arg.WFtsHeader,
		arg.WFtsBody,
		arg.WSimHeader,
		arg.WSimBody,
		arg.WIlikeHeader,
		arg.WIlikeBody,
		arg.WRecency,
		arg.Lang,
		arg.Query,
		arg.RecencyHalfLifeDays,
		arg.Simthreshold,
		arg.MinCreated,
		arg.MaxCreated,
		arg.MinUpdated,
		arg.MaxUpdated,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAdvancedRow
	for rows.Next() {
		var i SearchAdvancedRow
		if err := rows.Scan(
			&i.RFtsHeader,
			&i.RFtsBody,
			&i.RSimHeader,
			&i.RSimBody,
			&i.RIlikeHeader,
			&i.RIlikeBody,
			&i.RRecency,
			&i.Header,
			&i.Body,
			&i.HeaderHeadline,
			&i.BodyHeadline,
			&i.Ns,
			&i.AssociatedUrl,
			&i.Created,
			&i.Updated,
			&i.ExtraData,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAdvancedCount = `-- name: SearchAdvancedCount :one
WITH q AS (
  SELECT websearch_to_tsquery($7::regconfig, $1::text) AS qry
)
SELECT COUNT(*)::int AS n
FROM search s
CROSS JOIN q
WHERE search_match_advanced(
  s,
  q.qry,
  $1,
  $2::real,
  $3::timestamptz,
  $4::timestamptz,
  $5::timestamptz,
  $6::timestamptz
)
`

type SearchAdvancedCountParams struct {
	Query        string
	Simthreshold float32
	MinCreated   pgtype.Timestamptz
	MaxCreated   pgtype.Timestamptz
	MinUpdated   pgtype.Timestamptz
	MaxUpdated   pgtype.Timestamptz
	Lang         string
}

func (q *Queries) SearchAdvancedCount(ctx context.Context, arg SearchAdvancedCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, searchAdvancedCount,
		arg.Query,
		arg.Simthreshold,
		arg.MinCreated,
		arg.MaxCreated,
		arg.MinUpdated,
		arg.MaxUpdated,
		arg.Lang,
	)
	var n int32
	err := row.Scan(&n)
	return n, err
}

const searchBasic = `-- name: SearchBasic :many
WITH q AS (
  SELECT websearch_to_tsquery($3::regconfig, $6::text) AS qry
)
SELECT
  i.r_fts_header, i.r_fts_body, i.header_headline, i.body_headline, i.ns, i.associated_url, i.created, i.updated, i.extra_data,
  (
      i.r_fts_header
    + i.r_fts_body
  )::real AS rank
FROM (
  SELECT
    ($1::real   * ts_rank(s.fts_header, q.qry))::real AS r_fts_header,
    ($2::real     * ts_rank(s.fts_body,   q.qry))::real AS r_fts_body,
    ts_headline($3::regconfig, s.header, q.qry, 'StartSel=[START],StopSel=[STOP],HighlightAll=true')::text AS header_headline,
    ts_headline($3::regconfig, s.body,   q.qry, 'StartSel=[START],StopSel=[STOP],MaxFragments=5,MinWords=3,MaxWords=10,FragmentDelimiter=[CUT]')::text AS body_headline,
    s.ns,
    s.associated_url,
    s.created,
    s.updated,
    s.extra_data
  FROM search s
  CROSS JOIN q
  WHERE search_match_basic(s, q.qry)
) i
ORDER BY rank DESC
LIMIT $5
OFFSET $4
`

type SearchBasicParams struct {
	WFtsHeader float32
	WFtsBody   float32
	Lang       string
	Offset     int32
	Limit      int32
	Query      string
}

type SearchBasicRow struct {
	RFtsHeader     float32
	RFtsBody       float32
	HeaderHeadline string
	BodyHeadline   string
	Ns             string
	AssociatedUrl  pgtype.Text
	Created        pgtype.Timestamptz
	Updated        pgtype.Timestamptz
	ExtraData      pgtype.Text
	Rank           float32
}

func (q *Queries) SearchBasic(ctx context.Context, arg SearchBasicParams) ([]SearchBasicRow, error) {
	rows, err := q.db.Query(ctx, searchBasic,
		arg.WFtsHeader,
		arg.WFtsBody,
		arg.Lang,
		arg.Offset,
		arg.Limit,
		arg.Query,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBasicRow
	for rows.Next() {
		var i SearchBasicRow
		if err := rows.Scan(
			&i.RFtsHeader,
			&i.RFtsBody,
			&i.HeaderHeadline,
			&i.BodyHeadline,
			&i.Ns,
			&i.AssociatedUrl,
			&i.Created,
			&i.Updated,
			&i.ExtraData,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBasicCount = `-- name: SearchBasicCount :one
WITH q AS (
  SELECT websearch_to_tsquery($1::regconfig, $2::text) AS qry
)
SELECT COUNT(*)::int AS n
FROM search s
CROSS JOIN q
WHERE search_match_basic(s, q.qry)
`

type SearchBasicCountParams struct {
	Lang  string
	Query string
}

func (q *Queries) SearchBasicCount(ctx context.Context, arg SearchBasicCountParams) (int32, error) {
	row := q.db.QueryRow(ctx, searchBasicCount, arg.Lang, arg.Query)
	var n int32
	err := row.Scan(&n)
	return n, err
}

const updateSearchMetadata = `-- name: UpdateSearchMetadata :execresult
UPDATE search
SET
  extra_data = $1,
  created = $2,
  updated = $3,
  header = $4
WHERE ns = $5
  AND associated_url = $6
`

type UpdateSearchMetadataParams struct {
	ExtraData     pgtype.Text
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	Header        pgtype.Text
	Namespace     string
	AssociatedUrl pgtype.Text
}

func (q *Queries) UpdateSearchMetadata(ctx context.Context, arg UpdateSearchMetadataParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateSearchMetadata,
		arg.ExtraData,
		arg.Created,
		arg.Updated,
		arg.Header,
		arg.Namespace,
		arg.AssociatedUrl,
	)
}

const upsertSearchEntry = `-- name: UpsertSearchEntry :exec
INSERT INTO search (ns, associated_url, created, updated, header, body, lang, extra_data, skipped)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    FALSE
)
ON CONFLICT (ns, associated_url) DO UPDATE SET
    created        = EXCLUDED.created,
    updated        = EXCLUDED.updated,
    header         = EXCLUDED.header,
    body           = EXCLUDED.body,
    lang           = EXCLUDED.lang,
    associated_url = EXCLUDED.associated_url,
    extra_data     = EXCLUDED.extra_data,
    skipped        = EXCLUDED.skipped
`

type UpsertSearchEntryParams struct {
	Namespace     string
	AssociatedUrl pgtype.Text
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	Header        pgtype.Text
	Body          pgtype.Text
	Lang          interface{}
	ExtraData     pgtype.Text
}

func (q *Queries) UpsertSearchEntry(ctx context.Context, arg UpsertSearchEntryParams) error {
	_, err := q.db.Exec(ctx, upsertSearchEntry,
		arg.Namespace,
		arg.AssociatedUrl,
		arg.Created,
		arg.Updated,
		arg.Header,
		arg.Body,
		arg.Lang,
		arg.ExtraData,
	)
	return err
}

const upsertSkippedSearchEntry = `-- name: UpsertSkippedSearchEntry :exec
INSERT INTO search (ns, associated_url, created, updated, header, body, lang, extra_data, skipped)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  TRUE
)
ON CONFLICT (ns, associated_url) DO UPDATE SET
    created        = EXCLUDED.created,
    updated        = EXCLUDED.updated,
    header         = EXCLUDED.header,
    body           = EXCLUDED.body,
    lang           = EXCLUDED.lang,
    associated_url = EXCLUDED.associated_url,
    extra_data     = EXCLUDED.extra_data,
    skipped        = EXCLUDED.skipped
`

type UpsertSkippedSearchEntryParams struct {
	Namespace     string
	AssociatedUrl pgtype.Text
	Created       pgtype.Timestamptz
	Updated       pgtype.Timestamptz
	Header        pgtype.Text
	Body          pgtype.Text
	Lang          interface{}
	ExtraData     pgtype.Text
}

func (q *Queries) UpsertSkippedSearchEntry(ctx context.Context, arg UpsertSkippedSearchEntryParams) error {
	_, err := q.db.Exec(ctx, upsertSkippedSearchEntry,
		arg.Namespace,
		arg.AssociatedUrl,
		arg.Created,
		arg.Updated,
		arg.Header,
		arg.Body,
		arg.Lang,
		arg.ExtraData,
	)
	return err
}
